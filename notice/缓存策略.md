### 缓存策略

- 并发写没有问题，在数据库时，加了锁
- 只考虑读写并发的情况

#### Cache Aside Pattern（先更新数据库，在删缓存）

- 读取失效时(select expire)：从数据库取数据，成功后，放到缓存
- 读取命中时(select hit)：直接返回缓存数据
- 更新数据(update，delete)：先更新数据库，成功后，使缓存失效

##### 问题：

- 读操作取数据，没命中，去数据库取数据，取了旧数据
- 并发写操作，更新了旧数据，再使缓存失效
- 这时读操作，才将旧数据放入了缓存
- 产生条件：先读，后写，而且写操作还快！，所以概率很低

##### 解决：

- 缓存失效策略

#### Write Behind Caching Pattern（由缓存来更新数据库）



#### 异常问题

##### 缓存成功，数据库失败

- update：如果数据库失败，则不会删除缓存。没问题

##### 缓存失败，数据库成功

- update：缓存数据无效，有脏数据。缓存失效策略弥补

##### 缓存并发

- 多个并发查询没命中：对没命中的加锁

  ```java
  if(tryLock(500)){
    //获取锁  
  } else {
      //返回默认
  }
  ```

##### 缓存过期策略

- 定时过期：每个key有个定时器，过期立即删除。耗cpu
- 惰性过期：被范围时，先判断过期否，过期删除
- 定期过期：每隔一段时间，扫描有没有过期
- 数据**被更新时**，重新设置过期时间

##### 缓存淘汰策略

-  voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
-  volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
-  allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
-  allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
-  no-enviction（驱逐）：禁止驱逐数据